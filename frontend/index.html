<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>AI Crime Evidence Organizer</title>
    <style>
      * {
        box-sizing: border-box;
      }
      
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        color: #e8e8e8;
        min-height: 100vh;
        line-height: 1.6;
      }
      
      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 2rem;
      }
      
      header {
        text-align: center;
        margin-bottom: 3rem;
        padding: 2rem 0;
        border-bottom: 2px solid rgba(255, 255, 255, 0.1);
      }
      
      h1 {
        margin: 0 0 0.5rem 0;
        font-size: 2.5rem;
        font-weight: 700;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);
      }
      
      header p {
        margin: 0;
        font-size: 1.1rem;
        color: #b8b8b8;
        font-weight: 300;
      }
      
      section {
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        border-radius: 16px;
        padding: 2rem;
        margin-bottom: 2rem;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
                    0 0 0 1px rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
      }
      
      section:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4),
                    0 0 0 1px rgba(255, 255, 255, 0.15);
      }
      
      h2 {
        margin: 0 0 1.5rem 0;
        font-size: 1.75rem;
        font-weight: 600;
        color: #ffffff;
        border-bottom: 2px solid rgba(102, 126, 234, 0.3);
        padding-bottom: 0.75rem;
      }
      
      label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: 500;
        color: #d0d0d0;
        font-size: 0.95rem;
      }
      
      input[type="file"] {
        width: 100%;
        padding: 0.75rem;
        margin-bottom: 1rem;
        background: rgba(255, 255, 255, 0.05);
        border: 2px dashed rgba(102, 126, 234, 0.4);
        border-radius: 8px;
        color: #e8e8e8;
        font-size: 0.95rem;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      
      input[type="file"]:hover {
        border-color: rgba(102, 126, 234, 0.6);
        background: rgba(255, 255, 255, 0.08);
      }
      
      button {
        width: 100%;
        padding: 1rem 2rem;
        border: none;
        border-radius: 8px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #ffffff;
        font-weight: 600;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
      }
      
      button:active {
        transform: translateY(0);
      }
      
      .grid {
        display: grid;
        gap: 1rem;
      }
      
      @media (min-width: 768px) {
        .grid {
          grid-template-columns: repeat(2, 1fr);
        }
      }
      
      textarea {
        width: 100%;
        min-height: 400px;
        background: rgba(15, 15, 30, 0.6);
        color: #e8e8e8;
        border: 2px solid rgba(102, 126, 234, 0.3);
        border-radius: 12px;
        padding: 1.25rem;
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        font-size: 0.9rem;
        white-space: pre-wrap;
        word-wrap: break-word;
        line-height: 1.7;
        resize: vertical;
        transition: all 0.3s ease;
      }
      
      textarea:focus {
        outline: none;
        border-color: rgba(102, 126, 234, 0.6);
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }
      
      #status-message {
        margin-top: 1rem;
        padding: 1.25rem;
        background: rgba(102, 126, 234, 0.1);
        border-radius: 10px;
        border: 1px solid rgba(102, 126, 234, 0.3);
        backdrop-filter: blur(10px);
      }
      
      #status-text {
        color: #ffffff;
        font-weight: 500;
        margin-bottom: 0.5rem;
      }
      
      #progress-bar {
        margin-top: 0.75rem;
        height: 6px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
        overflow: hidden;
      }
      
      #progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        width: 0%;
        transition: width 0.3s ease;
        box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
      }
      
      .content-section {
        margin-top: 1rem;
        padding: 1.25rem;
        background: rgba(15, 15, 30, 0.4);
        border-radius: 10px;
        border: 1px solid rgba(102, 126, 234, 0.2);
      }
      
      .content-section h3 {
        margin-top: 0;
        color: #b8a9ff;
        font-weight: 600;
      }
      
      .entity-tag {
        display: inline-block;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #ffffff;
        padding: 0.35rem 0.75rem;
        border-radius: 6px;
        margin: 0.25rem;
        font-size: 0.85rem;
        font-weight: 500;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
      }
      
      /* Scrollbar styling */
      textarea::-webkit-scrollbar {
        width: 10px;
      }
      
      textarea::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 5px;
      }
      
      textarea::-webkit-scrollbar-thumb {
        background: rgba(102, 126, 234, 0.5);
        border-radius: 5px;
      }
      
      textarea::-webkit-scrollbar-thumb:hover {
        background: rgba(102, 126, 234, 0.7);
      }
      
      #graph-container {
        min-height: 600px;
        width: 100%;
      }
      
      #graph-info {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }
      
      #graph-section {
        margin-top: 2rem;
      }
    </style>
    <script src="https://unpkg.com/vis-network@latest/standalone/umd/vis-network.min.js"></script>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>AI Crime Evidence Organizer</h1>
        <p>Upload evidence, trigger AI processing, and review reports.</p>
      </header>

      <section>
      <h2>Upload & Process Evidence</h2>
      <form id="upload-form">
        <input type="file" id="file-input" accept=".pdf,.txt,.jpg,.jpeg,.png,.bmp,.tiff,.zip" multiple />
        <button type="submit">Upload & Process</button>
      </form>
      <div id="status-message" style="margin-top: 1rem; padding: 1rem; background: #0f172a; border-radius: 6px; display: none;">
        <div id="status-text"></div>
        <div id="progress-bar" style="margin-top: 0.5rem; height: 4px; background: #334155; border-radius: 2px; overflow: hidden; display: none;">
          <div id="progress-fill" style="height: 100%; background: #38bdf8; width: 0%; transition: width 0.3s;"></div>
        </div>
      </div>
    </section>

    <section>
      <h2>Analysis Report</h2>
      <textarea id="report-output" readonly placeholder="Upload a file to see the analysis report. The system will automatically process it and display results here."></textarea>
    </section>

    <section id="graph-section" style="display: none;">
      <h2>Case Relationship Graph</h2>
      <div id="graph-container" style="width: 100%; height: 600px; min-height: 600px; background: rgba(15, 15, 30, 0.6); border: 2px solid rgba(102, 126, 234, 0.3); border-radius: 12px; position: relative; overflow: hidden;"></div>
      <div id="graph-info" style="margin-top: 1rem; padding: 1rem; background: rgba(102, 126, 234, 0.1); border-radius: 8px; border: 1px solid rgba(102, 126, 234, 0.3); font-size: 0.9rem; color: #d0d0d0;">
        <em>Loading graph data...</em>
      </div>
    </section>


    <script>
      const API = "http://localhost:8000";

      function showStatus(message, showProgress = false) {
        const statusDiv = document.getElementById("status-message");
        const statusText = document.getElementById("status-text");
        const progressBar = document.getElementById("progress-bar");
        const progressFill = document.getElementById("progress-fill");
        
        statusText.textContent = message;
        statusDiv.style.display = "block";
        
        if (showProgress) {
          progressBar.style.display = "block";
          progressFill.style.width = "0%";
        } else {
          progressBar.style.display = "none";
        }
      }

      function updateProgress(percent) {
        const progressFill = document.getElementById("progress-fill");
        progressFill.style.width = percent + "%";
      }


      function formatReport(data) {
        // Validate data structure
        if (!data) {
          return "Error: No data received from server.";
        }
        
        let formattedReport = "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
        formattedReport += "        AI CRIME EVIDENCE ORGANIZER - ANALYSIS REPORT\n";
        formattedReport += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        
        // Case Information Header
        formattedReport += "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n";
        formattedReport += "â”‚ CASE INFORMATION                                            â”‚\n";
        formattedReport += "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n";
        
        formattedReport += `  â€¢ Case ID:        ${data.case_id || 'N/A'}\n`;
        
        // Handle generated_at - could be string or Date object
        let generatedDate = 'N/A';
        if (data.generated_at) {
          try {
            generatedDate = new Date(data.generated_at).toLocaleString();
          } catch (e) {
            generatedDate = String(data.generated_at);
          }
        }
        formattedReport += `  â€¢ Generated:      ${generatedDate}\n`;
        formattedReport += `  â€¢ Timeline Events: ${data.timeline_events !== undefined ? data.timeline_events : 'N/A'}\n`;
        formattedReport += `  â€¢ Inconsistencies: ${data.inconsistencies !== undefined ? data.inconsistencies : 'N/A'}\n\n`;
        
        // Extracted Content
        if (data.preview && data.preview.extracted_content) {
          formattedReport += "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n";
          formattedReport += "â”‚ EXTRACTED CONTENT FROM EVIDENCE FILES                       â”‚\n";
          formattedReport += "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n";
          
          data.preview.extracted_content.forEach((content, idx) => {
            formattedReport += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
            formattedReport += `  EVIDENCE ITEM ${idx + 1}\n`;
            formattedReport += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n`;
            
            formattedReport += `  ğŸ“„ File Type:        ${content.file_type || 'N/A'}\n`;
            formattedReport += `  ğŸ·ï¸  Classification:   ${content.classification?.label || 'Unknown'} (${(content.classification?.confidence * 100 || 0).toFixed(1)}% confidence)\n\n`;
            
            // Document Text - Full text, no truncation
            if (content.extracted_text) {
              formattedReport += `  â”Œâ”€ EXTRACTED TEXT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n`;
              formattedReport += `  â”‚\n`;
              const textLines = content.extracted_text.split('\n');
              textLines.forEach(line => {
                formattedReport += `  â”‚ ${line}\n`;
              });
              formattedReport += `  â”‚\n`;
              formattedReport += `  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n`;
            }
            
            // OCR Text (from images) - Full text
            if (content.ocr_text) {
              formattedReport += `  â”Œâ”€ OCR TEXT (from image) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n`;
              formattedReport += `  â”‚\n`;
              const ocrLines = content.ocr_text.split('\n');
              ocrLines.forEach(line => {
                formattedReport += `  â”‚ ${line}\n`;
              });
              formattedReport += `  â”‚\n`;
              formattedReport += `  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n`;
            }
            
            // Entities - Use structured data from backend as primary source
            const hasEntities = (content.persons && content.persons.length > 0) ||
                               (content.locations && content.locations.length > 0) ||
                               (content.timestamps && content.timestamps.length > 0) ||
                               (content.weapons && content.weapons.length > 0) ||
                               (content.legal_entities && Object.keys(content.legal_entities).length > 0);
            
            if (hasEntities) {
              formattedReport += `  â”Œâ”€ EXTRACTED ENTITIES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n`;
              formattedReport += `  â”‚\n`;
              
              // Extract Camera ID from text or locations
              const cameraIdMatch = content.extracted_text?.match(/Camera ID:\s*([^\n]+)/i) || 
                                   content.locations?.find(l => /cam-?\d+/i.test(l));
              if (cameraIdMatch) {
                const camId = cameraIdMatch[1]?.trim() || cameraIdMatch;
                formattedReport += `  â”‚ ğŸ“¹ Camera ID:     ${camId}\n`;
              }
              
              // Locations
              if (content.locations && content.locations.length > 0) {
                const locations = [...new Set(content.locations)];
                // Separate police stations and hospitals
                const policeStations = locations.filter(l => /police\s+station/i.test(l));
                const hospitals = locations.filter(l => /hospital/i.test(l));
                const otherLocations = locations.filter(l => !/police\s+station|hospital/i.test(l));
                
                if (policeStations.length > 0) {
                  formattedReport += `  â”‚ ğŸ›ï¸  Police Station: ${policeStations.join(', ')}\n`;
                }
                if (hospitals.length > 0) {
                  formattedReport += `  â”‚ ğŸ¥ Hospital:        ${hospitals.join(', ')}\n`;
                }
                if (otherLocations.length > 0) {
                  formattedReport += `  â”‚ ğŸ“ Locations:       ${otherLocations.join(', ')}\n`;
                }
              }
              
              // Persons - categorize by role
              if (content.persons && content.persons.length > 0) {
                const persons = [...new Set(content.persons)];
                const complainants = persons.filter(p => /complainant/i.test(p) || /rohan/i.test(p));
                const accused = persons.filter(p => /accused/i.test(p) || /akash/i.test(p));
                const witnesses = persons.filter(p => /witness|priya|security/i.test(p));
                const patients = persons.filter(p => /patient/i.test(p));
                const otherPersons = persons.filter(p => 
                  !complainants.includes(p) && !accused.includes(p) && 
                  !witnesses.includes(p) && !patients.includes(p)
                );
                
                if (complainants.length > 0) {
                  formattedReport += `  â”‚ ğŸ‘¤ Complainant:     ${complainants.join(', ')}\n`;
                }
                if (accused.length > 0) {
                  formattedReport += `  â”‚ âš–ï¸  Accused:         ${accused.join(', ')}\n`;
                }
                if (witnesses.length > 0) {
                  formattedReport += `  â”‚ ğŸ‘¥ Witnesses:       ${witnesses.join(', ')}\n`;
                }
                if (patients.length > 0) {
                  formattedReport += `  â”‚ ğŸ¥ Patient:         ${patients.join(', ')}\n`;
                }
                if (otherPersons.length > 0) {
                  formattedReport += `  â”‚ ğŸ‘¤ Persons:         ${otherPersons.join(', ')}\n`;
                }
              }
              
              // Timestamps - separate times and dates
              if (content.timestamps && content.timestamps.length > 0) {
                const timestamps = [...new Set(content.timestamps)];
                // Filter out ISO format timestamps, keep original formats
                const times = timestamps.filter(t => {
                  const tStr = String(t);
                  // Keep if it looks like a time (has : and AM/PM or just time format)
                  return (/\d{1,2}:\d{2}/.test(tStr) && /(am|pm|AM|PM)/i.test(tStr)) || 
                         (/\d{1,2}:\d{2}/.test(tStr) && !tStr.includes('T') && !tStr.includes('-'));
                });
                const dates = timestamps.filter(t => {
                  const tStr = String(t);
                  // Keep if it looks like a date (has month name or date format) and not ISO
                  return !times.includes(t) && !tStr.includes('T') && 
                         (/\d{1,2}\s+(january|february|march|april|may|june|july|august|september|october|november|december)/i.test(tStr) ||
                          /\d{1,2}\/\d{1,2}\/\d{4}/.test(tStr) || /\d{4}-\d{2}-\d{2}/.test(tStr));
                });
                const otherTimes = timestamps.filter(t => {
                  const tStr = String(t);
                  return !times.includes(t) && !dates.includes(t) && 
                         (tStr.toLowerCase().includes('around') || tStr.toLowerCase().includes('about'));
                });
                
                if (times.length > 0) {
                  formattedReport += `  â”‚ ğŸ• Times:           ${times.join(', ')}\n`;
                }
                if (otherTimes.length > 0) {
                  formattedReport += `  â”‚ ğŸ• Times:           ${otherTimes.join(', ')}\n`;
                }
                if (dates.length > 0) {
                  formattedReport += `  â”‚ ğŸ“… Date:            ${dates.join(', ')}\n`;
                }
              }
              
              // Weapons
              if (content.weapons && content.weapons.length > 0) {
                const weapons = [...new Set(content.weapons)];
                formattedReport += `  â”‚ ğŸ”ª Weapon${weapons.length > 1 ? 's' : ''}:          ${weapons.join(', ')}\n`;
              }
              
              // IPC Sections
              if (content.legal_entities && content.legal_entities.ipc_sections) {
                const ipcSections = Array.isArray(content.legal_entities.ipc_sections) 
                  ? content.legal_entities.ipc_sections 
                  : [content.legal_entities.ipc_sections];
                formattedReport += `  â”‚ âš–ï¸  IPC Sections:     ${ipcSections.join(', ')}\n`;
              }
              
              // Injuries
              if (content.injuries && content.injuries.length > 0) {
                const injuries = [...new Set(content.injuries)];
                formattedReport += `  â”‚ ğŸ©¹ Injuries:         ${injuries.join(', ')}\n`;
              }
              
              formattedReport += `  â”‚\n`;
              formattedReport += `  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n`;
            }

            formattedReport += "\n";
          });
        }
        
        // Case Summary (if available)
        if (data.preview && data.preview.case_summary) {
          formattedReport += "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n";
          formattedReport += "â”‚ CASE SUMMARY                                                  â”‚\n";
          formattedReport += "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n";
          formattedReport += `  ${data.preview.case_summary.split('\n').join('\n  ')}\n\n`;
        }

        // FILE DETAILS section (from evidence_map)
        if (data.preview && data.preview.evidence_map && data.preview.evidence_map.files && data.preview.evidence_map.files.length) {
          const ev = data.preview.evidence_map;
          // Per-file details
          if (ev.files && ev.files.length) {
            formattedReport += "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n";
            formattedReport += "â”‚ FILE DETAILS SUMMARY                                         â”‚\n";
            formattedReport += "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n";
            
            ev.files.forEach((f, idx) => {
              const fileName = f.file || f.filename || 'unknown';
              formattedReport += `  [${idx + 1}] ${fileName}\n`;
              formattedReport += `      Type: ${f.type || 'N/A'}\n`;
              
              // Clean persons
              const cleanFilePersons = (f.persons || []).filter(p => {
                const pStr = String(p).toLowerCase();
                return !pStr.includes('action taken') && !pStr.includes('time visible') && pStr.length > 2;
              });
              formattedReport += `      Persons: ${cleanFilePersons.length ? cleanFilePersons.join(', ') : 'N/A'}\n`;
              
              // Clean locations
              const cleanFileLocations = (f.locations || []).filter(l => {
                const lStr = String(l).toLowerCase();
                return !lStr.includes('sections applied') && lStr.length > 2;
              });
              formattedReport += `      Locations: ${cleanFileLocations.length ? cleanFileLocations.join(', ') : 'N/A'}\n`;
              
              // Clean timestamps - preserve original format
              const cleanFileTimestamps = (f.timestamps || []).filter(t => {
                const tStr = String(t);
                return !tStr.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/) || /\d{1,2}:\d{2}/.test(tStr);
              }).map(t => {
                const tStr = String(t);
                // If ISO format, try to extract readable time
                if (tStr.includes('T') && /\d{1,2}:\d{2}/.test(tStr)) {
                  const match = tStr.match(/(\d{1,2}:\d{2}(?::\d{2})?)\s*(AM|PM|am|pm)?/i);
                  return match ? `${match[1]}${match[2] ? ' ' + match[2] : ''}` : tStr;
                }
                return tStr;
              });
              formattedReport += `      Timestamps: ${cleanFileTimestamps.length ? cleanFileTimestamps.join(', ') : 'N/A'}\n`;
              
              formattedReport += `      Injuries: ${f.injuries && f.injuries.length ? f.injuries.join(', ') : 'N/A'}\n`;
              formattedReport += `      Weapons: ${f.weapons && f.weapons.length ? f.weapons.join(', ') : 'N/A'}\n\n`;
            });
          }
          // Entity -> files mapping (if present)
          if (ev.entity_files) {
            formattedReport += "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n";
            formattedReport += "â”‚ ENTITY TO FILE MAPPING                                       â”‚\n";
            formattedReport += "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n";
            
            for (const [cat, map] of Object.entries(ev.entity_files)) {
              formattedReport += `  ${cat.toUpperCase()}:\n`;
              for (const [entity, files] of Object.entries(map)) {
                // Filter out non-entity entities
                const entityStr = String(entity).toLowerCase();
                if (entityStr.includes('action taken') || entityStr.includes('time visible') || 
                    entityStr.includes('sections applied') || entityStr.length < 3) {
                  continue;
                }
                const uniqueFiles = [...new Set(files)];
                formattedReport += `    â€¢ ${entity} â†’ ${uniqueFiles.join(', ')}\n`;
              }
              formattedReport += "\n";
            }
          }
        }
        
        // Evidence-to-Evidence Relationships
        if (data.preview && data.preview.evidence_relationships && data.preview.evidence_relationships.length > 0) {
          formattedReport += "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n";
          formattedReport += "â”‚ EVIDENCE RELATIONSHIPS                                       â”‚\n";
          formattedReport += "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n";
          
          data.preview.evidence_relationships.forEach((rel, idx) => {
            formattedReport += `  [${idx + 1}] ${rel.source} â†’ ${rel.target}\n`;
            if (Array.isArray(rel.matches) && rel.matches.length) {
              rel.matches.forEach(match => {
                formattedReport += `      â€¢ ${match}\n`;
              });
            }
            formattedReport += "\n";
          });
        }
        
        
        // Inconsistencies
        if (data.preview && data.preview.inconsistencies && data.preview.inconsistencies.length > 0) {
          formattedReport += "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n";
          formattedReport += "â”‚ âš ï¸  INCONSISTENCIES DETECTED                                 â”‚\n";
          formattedReport += "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n";
          
          data.preview.inconsistencies.forEach((inc, idx) => {
            formattedReport += `  [${idx + 1}] ${inc.type || 'Unknown'}\n`;
            formattedReport += `      Details: ${inc.details || 'N/A'}\n`;
            if (inc.severity) {
              formattedReport += `      Severity: ${inc.severity}\n`;
            }
            formattedReport += "\n";
          });
        }
        
        // Missing Evidence
        if (data.missing_evidence && data.missing_evidence.length > 0) {
          formattedReport += "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n";
          formattedReport += "â”‚ ğŸ’¡ MISSING EVIDENCE SUGGESTIONS                             â”‚\n";
          formattedReport += "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n";
          
          data.missing_evidence.forEach((item, idx) => {
            formattedReport += `  [${idx + 1}] ${item}\n`;
          });
          formattedReport += "\n";
        }
        
        formattedReport += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
        formattedReport += "                          END OF REPORT\n";
        formattedReport += "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
        return formattedReport;
      }

      async function loadAndDisplayGraph(reportData) {
        // Get graph section element at function level for scope
        const graphSectionEl = document.getElementById('graph-section');
        
        try {
          // Wait for vis-network to load if not already loaded
          let retries = 0;
          while ((typeof vis === 'undefined' || !vis.Network) && retries < 10) {
            await new Promise(resolve => setTimeout(resolve, 100));
            retries++;
          }
          
          // Check if vis-network is loaded
          if (typeof vis === 'undefined' || !vis.Network) {
            console.error("vis-network library not loaded after waiting");
            const graphInfo = document.getElementById('graph-info');
            if (graphInfo && graphSectionEl) {
              graphInfo.innerHTML = '<strong style="color: #ef4444;">Error:</strong> Graph visualization library failed to load. Please refresh the page or check your internet connection.';
              graphSectionEl.style.display = 'block';
            }
            return;
          }
          
          console.log("vis-network library loaded successfully");
          
          // Extract persons and locations from current case files
          if (!reportData || !reportData.preview || !reportData.preview.extracted_content) {
            console.log("No report data available for graph");
            return;
          }
          
          const extractedContent = reportData.preview.extracted_content;
          
          // Collect all unique persons and locations from all files
          const allPersons = new Set();
          const allLocations = new Set();
          const personLocationMap = new Map(); // person -> Set of locations they appear with
          
          extractedContent.forEach(content => {
            const persons = content.persons || [];
            const locations = content.locations || [];
            
            persons.forEach(person => {
              if (person && typeof person === 'string' && person.trim().length > 0) {
                allPersons.add(person.trim());
                // Track which locations this person appears with
                if (!personLocationMap.has(person.trim())) {
                  personLocationMap.set(person.trim(), new Set());
                }
                locations.forEach(loc => {
                  if (loc && typeof loc === 'string' && loc.trim().length > 0) {
                    allLocations.add(loc.trim());
                    personLocationMap.get(person.trim()).add(loc.trim());
                  }
                });
              }
            });
            
            locations.forEach(loc => {
              if (loc && typeof loc === 'string' && loc.trim().length > 0) {
                allLocations.add(loc.trim());
              }
            });
          });
          
          // Always show graph section
          if (graphSectionEl) {
            graphSectionEl.style.display = 'block';
          }
          
          if (allPersons.size === 0 && allLocations.size === 0) {
            console.log("No persons or locations found in current case");
            const graphInfo = document.getElementById('graph-info');
            const graphContainer = document.getElementById('graph-container');
            if (graphInfo) {
              graphInfo.innerHTML = '<strong>No entities found.</strong> No persons or locations were extracted from the uploaded files.';
            }
            if (graphContainer) {
              graphContainer.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #9ca3af; font-size: 1.1rem;">No persons or locations found in this case.</div>';
            }
            return;
          }
          
          console.log("Found", allPersons.size, "persons and", allLocations.size, "locations");
          
          // Create nodes - simple person and location nodes
          const nodes = [];
          
          // Add person nodes
          Array.from(allPersons).forEach((person, idx) => {
            nodes.push({
              id: `person-${idx}`,
              label: person,
              title: `Person: ${person}`,
              color: { 
                background: '#667eea', 
                border: '#764ba2', 
                highlight: { background: '#8b5cf6', border: '#a78bfa' } 
              },
              shape: 'ellipse',
              font: { color: '#ffffff', size: 14, face: 'Segoe UI', bold: true },
              borderWidth: 2,
              size: 25
            });
          });
          
          // Add location nodes
          Array.from(allLocations).forEach((location, idx) => {
            nodes.push({
              id: `location-${idx}`,
              label: location,
              title: `Location: ${location}`,
              color: { 
                background: '#10b981', 
                border: '#059669', 
                highlight: { background: '#34d399', border: '#6ee7b7' } 
              },
              shape: 'box',
              font: { color: '#ffffff', size: 14, face: 'Segoe UI', bold: true },
              borderWidth: 2,
              size: 25
            });
          });
          
          // Create edges - connect persons to locations they appear with
          const edges = [];
          const personNodes = nodes.filter(n => n.shape === 'ellipse');
          const locationNodes = nodes.filter(n => n.shape === 'box');
          
          personLocationMap.forEach((locations, person) => {
            const personNode = personNodes.find(n => n.label === person);
            if (personNode) {
              locations.forEach(location => {
                const locationNode = locationNodes.find(n => n.label === location);
                if (locationNode) {
                  edges.push({
                    id: `edge-${personNode.id}-${locationNode.id}`,
                    from: personNode.id,
                    to: locationNode.id,
                    color: { color: '#667eea', highlight: '#8b5cf6' },
                    width: 2,
                    arrows: { to: { enabled: false } }
                  });
                }
              });
            }
          });
          
          console.log("Created", nodes.length, "nodes and", edges.length, "edges");
          
          const data = { nodes: nodes, edges: edges };
          
          const options = {
            nodes: {
              borderWidth: 2,
              shadow: false,
              font: {
                size: 16,
                face: 'Segoe UI',
                color: '#ffffff',
                bold: true
              },
              margin: 10,
              widthConstraint: {
                maximum: 150
              }
            },
            edges: {
              shadow: false,
              smooth: {
                type: 'straight',
                roundness: 0
              },
              font: {
                size: 12,
                face: 'Segoe UI',
                color: '#ffffff',
                background: 'rgba(0,0,0,0.7)',
                strokeWidth: 2,
                strokeColor: '#000000'
              },
              arrows: {
                to: {
                  enabled: false
                }
              },
              color: {
                color: '#667eea',
                highlight: '#8b5cf6'
              },
              width: 2
            },
            physics: {
              enabled: true,
              stabilization: {
                enabled: true,
                iterations: 100,
                fit: true
              },
              barnesHut: {
                gravitationalConstant: -3000,
                centralGravity: 0.3,
                springLength: 200,
                springConstant: 0.05,
                damping: 0.1
              }
            },
            interaction: {
              hover: true,
              tooltipDelay: 100,
              zoomView: true,
              dragView: true,
              selectConnectedEdges: true
            },
            layout: {
              improvedLayout: true,
              hierarchical: {
                enabled: false
              }
            }
          };
          
          const container = document.getElementById('graph-container');
          if (!container) {
            console.error("Graph container element not found");
            return;
          }
          
          // Clear container first and show loading
          container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #9ca3af;">Rendering graph...</div>';
          
          // Ensure graph section is visible
          if (graphSectionEl) {
            graphSectionEl.style.display = 'block';
          }
          
          // Small delay to ensure container is ready
          await new Promise(resolve => setTimeout(resolve, 100));
          
          // Clear container again before rendering
          container.innerHTML = '';
          
          // Create network
          try {
            const network = new vis.Network(container, data, options);
            console.log("Graph network created successfully with", nodes.length, "nodes and", edges.length, "edges");
          
          // Update graph info
          const graphInfo = document.getElementById('graph-info');
          if (graphInfo) {
            const personCount = nodes.filter(n => n.shape === 'ellipse').length;
            const locationCount = nodes.filter(n => n.shape === 'box').length;
            graphInfo.innerHTML = `
              <div style="display: flex; gap: 2rem; align-items: center; flex-wrap: wrap;">
                <div><strong style="color: #667eea;">Persons:</strong> <span style="color: #e2e8f0;">${personCount}</span></div>
                <div><strong style="color: #10b981;">Locations:</strong> <span style="color: #e2e8f0;">${locationCount}</span></div>
                <div><strong style="color: #9ca3af;">Connections:</strong> <span style="color: #e2e8f0;">${edges.length}</span></div>
              </div>
              <div style="margin-top: 0.5rem; font-size: 0.85rem; color: #9ca3af;">
                <span style="display: inline-block; width: 12px; height: 12px; background: #667eea; border-radius: 50%; margin-right: 5px;"></span>Person
                <span style="display: inline-block; width: 12px; height: 12px; background: #10b981; margin-left: 15px; margin-right: 5px;"></span>Location
                <span style="margin-left: 15px;">â€¢ Drag nodes to rearrange â€¢ Scroll to zoom â€¢ Hover for details</span>
              </div>
            `;
          }
          
            // Handle node click events
            network.on("click", function (params) {
              if (params.nodes.length > 0) {
                const nodeId = params.nodes[0];
                const node = nodes.find(n => n.id === nodeId);
                if (node) {
                  console.log("Selected node:", node);
                }
              }
            });
            
            // Handle errors during rendering
            network.on("stabilizationEnd", function() {
              console.log("Graph stabilization complete");
            });
            
            network.on("stabilizationProgress", function(params) {
              console.log("Graph stabilization progress:", params.iterations, "/", params.total);
            });
            
          } catch (renderError) {
            console.error("Error rendering graph network:", renderError);
            container.innerHTML = `<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #ef4444; padding: 2rem;">Error rendering graph: ${renderError.message}</div>`;
            throw renderError;
          }
          
        } catch (error) {
          console.error("Error loading graph:", error);
          const graphInfo = document.getElementById('graph-info');
          const graphSectionErr = document.getElementById('graph-section');
          const graphContainer = document.getElementById('graph-container');
          if (graphInfo) {
            graphInfo.innerHTML = `<strong style="color: #ef4444;">Error loading graph:</strong> ${error.message}`;
          }
          if (graphSectionErr) {
            graphSectionErr.style.display = 'block';
          }
          if (graphContainer) {
            graphContainer.innerHTML = `<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #ef4444; padding: 2rem;">Error: ${error.message}</div>`;
          }
        }
      }

      document.getElementById("upload-form").addEventListener("submit", async (e) => {
        e.preventDefault();
        const fileInput = document.getElementById("file-input");
        if (!fileInput.files.length) {
          alert("Please select a file first");
          return;
        }

        const file = fileInput.files[0];
        let caseId = null;
        let artifactPath = null;
        showStatus("Uploading file...", true);
        updateProgress(10);

        try {
          // Step 1: Upload file(s) or zip archive
          const formData = new FormData();
          // Multiple files -> upload folder endpoint
          if (fileInput.files.length > 1 || file.name.toLowerCase().endsWith('.zip')) {
            for (let i = 0; i < fileInput.files.length; i++) {
              formData.append('files', fileInput.files[i]);
            }
            showStatus('Uploading files...', true);
            updateProgress(20);
            const uploadRes = await fetch(`${API}/evidence/upload_folder`, {
              method: 'POST',
              body: formData,
            });
            if (!uploadRes.ok) {
              throw new Error(`Upload failed: ${uploadRes.statusText}`);
            }
            const uploadData = await uploadRes.json();
            caseId = uploadData.case_id;
            // Trigger case-level processing
            showStatus('Files uploaded. Processing with AI...', true);
            updateProgress(40);
            const processRes = await fetch(`${API}/evidence/process_case`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ case_id: caseId })
            });
            if (!processRes.ok) {
              throw new Error(`Processing failed: ${processRes.statusText}`);
            }
          } else {
            // Single file flow uses existing upload endpoint
            formData.append('file', file);
            showStatus('Uploading file...', true);
            updateProgress(20);
            const uploadRes = await fetch(`${API}/evidence/upload`, {
              method: 'POST',
              body: formData
            });
            if (!uploadRes.ok) {
              throw new Error(`Upload failed: ${uploadRes.statusText}`);
            }
            const uploadData = await uploadRes.json();
            caseId = uploadData.case_id;
            artifactPath = uploadData.stored_path;

            showStatus('File uploaded. Processing with AI...', true);
            updateProgress(40);
            // Step 2: Process evidence (automatic)
            const processRes = await fetch(`${API}/evidence/process`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ case_id: caseId, artifact_path: artifactPath })
            });
            if (!processRes.ok) {
              throw new Error(`Processing failed: ${processRes.statusText}`);
            }
          }

          // Upload success validated above in branch-specific checks

          // upload/process handled above, now poll for reports

          showStatus("AI processing in progress... This may take 2-5 minutes on first run (downloading models)...", true);
          updateProgress(60);

          // Step 3: Wait for processing to complete (now synchronous, but we still poll for report)
          // Poll for report (check every 2 seconds, max 6 minutes for first-time model downloads)
          let attempts = 0;
          const maxAttempts = 180; // 180 attempts * 2 seconds = 6 minutes
          let reportData = null;

          while (attempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 2000)); // Check every 2 seconds
            attempts++;
            const elapsedSeconds = attempts * 2;
            const progressPercent = Math.min(60 + (attempts * 0.2), 98); // Progress from 60% to 98%
            updateProgress(progressPercent);

            try {
              const reportRes = await fetch(`${API}/reports/${caseId}`);
              if (reportRes.ok) {
                const jsonData = await reportRes.json();
                // Debug: log the response
                console.log("Report API response:", jsonData);
                // Validate that we got valid data
                if (jsonData && (jsonData.case_id || jsonData.caseId)) {
                  // Handle both snake_case and camelCase
                  reportData = jsonData;
                  // Normalize case_id if needed
                  if (!reportData.case_id && reportData.caseId) {
                    reportData.case_id = reportData.caseId;
                  }
                  break;
                } else {
                  console.warn("Report data incomplete, waiting...", jsonData);
                  // If we got a response but it's incomplete, log it for debugging
                  if (jsonData) {
                    console.warn("Received data keys:", Object.keys(jsonData));
                  }
                }
              } else if (reportRes.status === 202) {
                // 202 Accepted = processing in progress, continue polling
                // Don't log this as an error, it's expected
              } else if (reportRes.status === 404) {
                // 404 = not started yet, continue polling
                // Don't log this as an error, it's expected
              } else {
                // Other error status - try to get error message
                const errorText = await reportRes.text();
                console.warn(`Report check returned status ${reportRes.status}:`, errorText);
              }
            } catch (err) {
              // Network error, continue polling
              // Don't log this as an error during polling
              console.warn("Network error during polling (expected):", err.message);
            }

            // Show elapsed time with helpful message
            const minutes = Math.floor(elapsedSeconds / 60);
            const seconds = elapsedSeconds % 60;
            let statusMsg = "";
            if (elapsedSeconds < 30) {
              statusMsg = `Processing started... (${elapsedSeconds}s)`;
            } else if (elapsedSeconds < 120) {
              statusMsg = `Processing... Models may be downloading (${minutes}m ${seconds}s)`;
            } else {
              statusMsg = `Still processing... First-time model download can take 3-5 minutes (${minutes}m ${seconds}s)`;
            }
            showStatus(statusMsg, true);
          }

          if (!reportData) {
            throw new Error("Report generation timed out after 6 minutes. The BERT model (440MB) may still be downloading. Please wait a bit longer and try refreshing, or check server logs.");
          }

          // Validate report data before formatting
          if (!reportData.case_id) {
            console.error("Invalid report data received:", reportData);
            throw new Error("Received invalid report data from server. Please check server logs.");
          }

          showStatus("Processing complete! Generating report...", true);
          updateProgress(100);

          // Step 4: Display formatted report
          console.log("Formatting report with data:", reportData);
          const formattedReport = formatReport(reportData);
          document.getElementById("report-output").value = formattedReport;

          showStatus("âœ… Analysis complete! Report generated below.", false);
          
          // Load and display graph (with delay to ensure vis-network is loaded)
          setTimeout(async () => {
            await loadAndDisplayGraph(jsonData);
          }, 500);
          
          // Hide progress after 3 seconds
          setTimeout(() => {
            document.getElementById("status-message").style.display = "none";
          }, 3000);

        } catch (error) {
          console.error("Full error:", error);
          showStatus(`âŒ Error: ${error.message}`, false);
          const errorDetails = `Error: ${error.message}\n\nPlease try again or check:\n1. Server is running\n2. File format is supported (.pdf, .txt, .jpg, .png)\n3. File is not corrupted\n4. Check browser console (F12) for more details`;
          document.getElementById("report-output").value = errorDetails;
        }
      });
    </script>
    </div>
  </body>
</html>


