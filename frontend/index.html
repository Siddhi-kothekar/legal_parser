<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>AI Crime Evidence Organizer</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 2rem;
        background: #0f172a;
        color: #f8fafc;
      }
      h1 {
        margin-bottom: 0.5rem;
      }
      section {
        background: #1e293b;
        border-radius: 12px;
        padding: 1.5rem;
        margin-bottom: 1.5rem;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
      }
      label,
      input,
      button,
      textarea {
        width: 100%;
        margin-top: 0.5rem;
        margin-bottom: 1rem;
      }
      button {
        padding: 0.75rem;
        border: none;
        border-radius: 6px;
        background: #38bdf8;
        color: #0f172a;
        font-weight: bold;
        cursor: pointer;
      }
      button:hover {
        background: #0ea5e9;
      }
      .grid {
        display: grid;
        gap: 1rem;
      }
      @media (min-width: 768px) {
        .grid {
          grid-template-columns: repeat(2, 1fr);
        }
      }
      textarea {
        min-height: 300px;
        background: #0f172a;
        color: #f8fafc;
        border: 1px solid #334155;
        border-radius: 6px;
        padding: 0.75rem;
        font-family: 'Courier New', monospace;
        font-size: 0.9rem;
        white-space: pre-wrap;
        word-wrap: break-word;
      }
      .content-section {
        margin-top: 1rem;
        padding: 1rem;
        background: #0f172a;
        border-radius: 6px;
        border: 1px solid #334155;
      }
      .content-section h3 {
        margin-top: 0;
        color: #38bdf8;
      }
      .entity-tag {
        display: inline-block;
        background: #1e40af;
        color: #fff;
        padding: 0.2rem 0.5rem;
        border-radius: 4px;
        margin: 0.2rem;
        font-size: 0.85rem;
      }
      #graph-container {
        width: 100%;
        height: 420px;
        background: #0f172a;
        border: 1px solid #334155;
        border-radius: 6px;
        margin-top: 1rem;
      }
      #graph-status {
        margin-top: 0.5rem;
        font-size: 0.9rem;
        color: #94a3b8;
      }
    </style>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  </head>
  <body>
    <h1>AI Crime Evidence Organizer</h1>
    <p>Upload evidence, trigger AI processing, and review reports.</p>

    <section>
      <h2>Upload & Process Evidence</h2>
      <form id="upload-form">
        <input type="file" id="file-input" accept=".pdf,.txt,.jpg,.jpeg,.png,.bmp,.tiff,.zip" multiple />
        <button type="submit">Upload & Process</button>
      </form>
      <div id="status-message" style="margin-top: 1rem; padding: 1rem; background: #0f172a; border-radius: 6px; display: none;">
        <div id="status-text"></div>
        <div id="progress-bar" style="margin-top: 0.5rem; height: 4px; background: #334155; border-radius: 2px; overflow: hidden; display: none;">
          <div id="progress-fill" style="height: 100%; background: #38bdf8; width: 0%; transition: width 0.3s;"></div>
        </div>
      </div>
    </section>

    <section>
      <h2>Analysis Report</h2>
      <textarea id="report-output" readonly placeholder="Upload a file to see the analysis report. The system will automatically process it and display results here."></textarea>
    </section>

    <section>
      <h2>Load Case by ID</h2>
      <p>Paste any processed case identifier (e.g., copied from the graph) to instantly view its full report.</p>
      <div class="grid">
        <input type="text" id="manual-case-id" placeholder="Enter case ID (like 9bc6495f1a3a4f53bbcb8238b64b928d)" />
        <button type="button" id="manual-case-button">Load Case</button>
      </div>
    </section>

    <section>
      <h2>Crime Case Graph</h2>
      <p>Each node represents a processed case. Click a node to load its report and evidence context. Edges explain why two cases are linked (same person, location, weapon, date overlap, or semantic similarity).</p>
      <div id="graph-status">Graph will update after cases are processed.</div>
      <div id="graph-container"></div>
    </section>

    <script>
      const API = "http://localhost:8000";

      function showStatus(message, showProgress = false) {
        const statusDiv = document.getElementById("status-message");
        const statusText = document.getElementById("status-text");
        const progressBar = document.getElementById("progress-bar");
        const progressFill = document.getElementById("progress-fill");
        
        statusText.textContent = message;
        statusDiv.style.display = "block";
        
        if (showProgress) {
          progressBar.style.display = "block";
          progressFill.style.width = "0%";
        } else {
          progressBar.style.display = "none";
        }
      }

      function updateProgress(percent) {
        const progressFill = document.getElementById("progress-fill");
        progressFill.style.width = percent + "%";
      }

      let caseNetwork = null;
      let graphNodeMap = new Map();
      let graphEdgeMap = new Map();

      function formatReport(data) {
        // Validate data structure
        if (!data) {
          return "Error: No data received from server.";
        }
        
        let formattedReport = "=== AI CRIME EVIDENCE ORGANIZER REPORT ===\n\n";
        formattedReport += `Case ID: ${data.case_id || 'N/A'}\n`;
        
        // Handle generated_at - could be string or Date object
        let generatedDate = 'N/A';
        if (data.generated_at) {
          try {
            generatedDate = new Date(data.generated_at).toLocaleString();
          } catch (e) {
            generatedDate = String(data.generated_at);
          }
        }
        formattedReport += `Generated: ${generatedDate}\n`;
        formattedReport += `Timeline Events: ${data.timeline_events !== undefined ? data.timeline_events : 'N/A'}\n`;
        formattedReport += `Inconsistencies Found: ${data.inconsistencies !== undefined ? data.inconsistencies : 'N/A'}\n\n`;
        
        // Extracted Content
        if (data.preview && data.preview.extracted_content) {
          formattedReport += "=== EXTRACTED CONTENT ===\n\n";
          data.preview.extracted_content.forEach((content, idx) => {
            formattedReport += `--- Evidence Item ${idx + 1} ---\n`;
            formattedReport += `Type: ${content.file_type}\n`;
            formattedReport += `Classification: ${content.classification?.label || 'Unknown'} (${(content.classification?.confidence * 100 || 0).toFixed(1)}%)\n\n`;
            
            // Document Text
            if (content.extracted_text) {
              formattedReport += "EXTRACTED TEXT:\n";
              formattedReport += content.extracted_text.substring(0, 2000);
              if (content.extracted_text.length > 2000) {
                formattedReport += "\n... (truncated)";
              }
              formattedReport += "\n\n";
            }
            
            // OCR Text (from images)
            if (content.ocr_text) {
              formattedReport += "OCR TEXT (from image):\n";
              formattedReport += content.ocr_text.substring(0, 1000);
              if (content.ocr_text.length > 1000) {
                formattedReport += "\n... (truncated)";
              }
              formattedReport += "\n\n";
            }
            
            // Entities
            if (content.entities && content.entities.length > 0) {
              formattedReport += "ENTITIES FOUND:\n";
              content.entities.forEach(entity => {
                formattedReport += `  - ${entity.entity} (${entity.label})\n`;
              });
              formattedReport += "\n";
            }

            // Legal Entities
            if (content.legal_entities) {
              formattedReport += "LEGAL ENTITIES:\n";
              for (const [k,v] of Object.entries(content.legal_entities)) {
                if (Array.isArray(v) && v.length > 0) {
                  formattedReport += `  - ${k}: ${v.join(', ')}\n`;
                }
              }
              formattedReport += "\n";
            }
            
            // Objects Detected (from images)
            if (content.objects_detected && content.objects_detected.length > 0) {
              formattedReport += "OBJECTS DETECTED:\n";
              content.objects_detected.forEach(obj => {
                formattedReport += `  - ${obj.class} (confidence: ${(obj.confidence * 100).toFixed(1)}%)\n`;
              });
              formattedReport += "\n";
            }
            
            // Timestamps
            if (content.timestamps && content.timestamps.length > 0) {
              formattedReport += "TIMESTAMPS FOUND:\n";
              content.timestamps.forEach(ts => {
                formattedReport += `  - ${ts}\n`;
              });
              formattedReport += "\n";
            }
            
            // Locations
            if (content.locations && content.locations.length > 0) {
              formattedReport += "LOCATIONS FOUND:\n";
              content.locations.forEach(loc => {
                formattedReport += `  - ${loc}\n`;
              });
              formattedReport += "\n";
            }
            
            formattedReport += "\n";
          });
        }
        
        // Case Summary (if available)
        if (data.preview && data.preview.case_summary) {
          formattedReport += "=== CASE SUMMARY ===\n\n";
          formattedReport += data.preview.case_summary;
          formattedReport += "\n\n";
        }

        // Evidence Map
        if (data.preview && data.preview.evidence_map) {
          const ev = data.preview.evidence_map;
          formattedReport += "=== EVIDENCE MAP ===\n\n";
          formattedReport += `Persons: ${ev.case_persons ? ev.case_persons.join(', ') : 'N/A'}\n`;
          formattedReport += `Locations: ${ev.case_locations ? ev.case_locations.join(', ') : 'N/A'}\n`;
          formattedReport += `Timestamps: ${ev.case_timestamps ? ev.case_timestamps.join(', ') : 'N/A'}\n`;
          formattedReport += `Injuries: ${ev.case_injuries ? ev.case_injuries.join(', ') : 'N/A'}\n`;
          formattedReport += `Weapons: ${ev.case_weapons ? ev.case_weapons.join(', ') : 'N/A'}\n`;
          formattedReport += `IPC: ${ev.ipc_sections ? ev.ipc_sections.join(', ') : 'N/A'}\n`;
          formattedReport += `FIR Numbers: ${ev.fir_numbers ? ev.fir_numbers.join(', ') : 'N/A'}\n`;
          formattedReport += `MLC Numbers: ${ev.mlc_numbers ? ev.mlc_numbers.join(', ') : 'N/A'}\n`;
          formattedReport += `Hospital Names: ${ev.hospital_names ? ev.hospital_names.join(', ') : 'N/A'}\n`;
          formattedReport += `Vehicle Numbers: ${ev.vehicle_numbers ? ev.vehicle_numbers.join(', ') : 'N/A'}\n\n`;
          // Per-file details
          if (ev.files && ev.files.length) {
            formattedReport += "=== FILE DETAILS ===\n\n";
            ev.files.forEach((f) => {
              formattedReport += `File: ${f.file} | Type: ${f.type}\n`;
              formattedReport += `  Persons: ${f.persons && f.persons.length ? f.persons.join(', ') : 'N/A'}\n`;
              formattedReport += `  Locations: ${f.locations && f.locations.length ? f.locations.join(', ') : 'N/A'}\n`;
              formattedReport += `  Timestamps: ${f.timestamps && f.timestamps.length ? f.timestamps.join(', ') : 'N/A'}\n`;
              formattedReport += `  Injuries: ${f.injuries && f.injuries.length ? f.injuries.join(', ') : 'N/A'}\n`;
              formattedReport += `  Weapons: ${f.weapons && f.weapons.length ? f.weapons.join(', ') : 'N/A'}\n\n`;
            });
          }
          // Entity -> files mapping (if present)
          if (ev.entity_files) {
            formattedReport += "=== ENTITY -> FILES ===\n";
            for (const [cat, map] of Object.entries(ev.entity_files)) {
              formattedReport += `${cat.toUpperCase()}:\n`;
              for (const [entity, files] of Object.entries(map)) {
                formattedReport += `  - ${entity}: ${files.join(', ')}\n`;
              }
              formattedReport += "\n";
            }
          }
        }
        
        // Relationships / Linked Cases
        if (data.preview && data.preview.relationships && data.preview.relationships.length > 0) {
          formattedReport += "\n=== RELATIONSHIPS ===\n\n";
          data.preview.relationships.forEach((rel, idx) => {
            const otherCase = rel.target || rel.case_id || 'Unknown';
            formattedReport += `${idx + 1}. Linked Case: ${otherCase}\n`;
            if (Array.isArray(rel.reasons) && rel.reasons.length) {
              rel.reasons.forEach(reason => {
                formattedReport += `   - ${reason}\n`;
              });
            }
            if (rel.similarity) {
              formattedReport += `   Similarity: ${(rel.similarity * 100).toFixed(1)}%\n`;
            }
            if (rel.shared_entities) {
              const sharedEntries = [];
              for (const [key, values] of Object.entries(rel.shared_entities)) {
                if (Array.isArray(values) && values.length) {
                  sharedEntries.push(`${key}: ${values.slice(0, 3).join(', ')}`);
                }
              }
              if (sharedEntries.length) {
                formattedReport += `   Shared: ${sharedEntries.join(' | ')}\n`;
              }
            }
            formattedReport += "\n";
          });
        }
        
        // Structured Timeline
        if (data.preview && data.preview.timeline && Array.isArray(data.preview.timeline)) {
          formattedReport += "=== STRUCTURED TIMELINE ===\n\n";
          formattedReport += "Time          | Source      | Event                                    | Notes/Conflicts\n";
          formattedReport += "--------------|-------------|------------------------------------------|----------------\n";
          
          data.preview.timeline.forEach((item, idx) => {
            const time = item.time || item.timestamp || "N/A";
            const source = item.source || "Unknown";
            const event = item.event || item.description || "N/A";
            const notes = item.notes || "";
            
            // Format for table-like display
            const timeCol = (time + "          ").substring(0, 13);
            const sourceCol = (source + "           ").substring(0, 11);
            const eventCol = (event + "                                        ").substring(0, 40);
            const notesCol = notes.substring(0, 50);
            
            formattedReport += `${timeCol}| ${sourceCol}| ${eventCol}| ${notesCol}\n`;
          });
          formattedReport += "\n";
        } else if (data.preview && data.preview.timeline) {
          // Fallback to old format
          formattedReport += "=== TIMELINE ===\n\n";
          data.preview.timeline.forEach((event, idx) => {
            formattedReport += `${idx + 1}. ${event}\n`;
          });
          formattedReport += "\n";
        }
        
        // Inconsistencies
        if (data.preview && data.preview.inconsistencies && data.preview.inconsistencies.length > 0) {
          formattedReport += "=== INCONSISTENCIES DETECTED ===\n\n";
          data.preview.inconsistencies.forEach((inc, idx) => {
            formattedReport += `${idx + 1}. Type: ${inc.type || 'Unknown'}\n`;
            formattedReport += `   Details: ${inc.details || 'N/A'}\n`;
            if (inc.severity) {
              formattedReport += `   Severity: ${inc.severity}\n`;
            }
            formattedReport += "\n";
          });
        }
        
        // Missing Evidence
        if (data.missing_evidence && data.missing_evidence.length > 0) {
          formattedReport += "=== MISSING EVIDENCE SUGGESTIONS ===\n\n";
          data.missing_evidence.forEach((item, idx) => {
            formattedReport += `${idx + 1}. ${item}\n`;
          });
        }
        
        formattedReport += "\n=== END OF REPORT ===";
        return formattedReport;
      }

      async function loadCaseGraph(focusCaseId = null) {
        const statusEl = document.getElementById("graph-status");
        if (!statusEl) return;
        try {
          statusEl.textContent = "Loading case graph...";
          const res = await fetch(`${API}/reports/graph`);
          if (!res.ok) {
            statusEl.textContent = `Unable to load graph: ${res.statusText}`;
            return;
          }
          const graphData = await res.json();
          if (!graphData.nodes || graphData.nodes.length === 0) {
            statusEl.textContent = "Process at least one case to see the crime network.";
            document.getElementById("graph-container").innerHTML = "";
            return;
          }
          statusEl.textContent = `Graph updated ${new Date(graphData.generated_at).toLocaleString()}`;
          renderCaseGraph(graphData, focusCaseId);
        } catch (error) {
          console.error("Graph load error:", error);
          statusEl.textContent = `Graph load failed: ${error.message}`;
        }
      }

      function renderCaseGraph(graphData, focusCaseId = null) {
        const container = document.getElementById("graph-container");
        if (!container || typeof vis === "undefined") {
          return;
        }

        graphNodeMap = new Map();
        graphEdgeMap = new Map();

        const nodes = new vis.DataSet(
          (graphData.nodes || []).map((node) => {
            const color = node.type === "person" ? "#38bdf8" : "#f97316";
            const shape = node.type === "person" ? "dot" : "square";
            const titleLines = [
              `<strong>${node.label}</strong>`,
              `Type: ${node.type}`,
              `Linked cases: ${node.cases ? node.cases.length : 0}`,
            ];
            if (node.cases && node.cases.length) {
              titleLines.push(`Cases: ${node.cases.slice(0, 5).join(", ")}`);
            }
            const datasetNode = {
              id: node.id,
              label: node.label,
              title: titleLines.join("<br/>"),
              value: Math.max(1, node.count || 1),
              color,
              shape,
            };
            graphNodeMap.set(node.id, node);
            return datasetNode;
          })
        );

        const edges = new vis.DataSet(
          (graphData.edges || []).map((edgeRaw) => {
            const edgeId = edgeRaw.id || `${edgeRaw.source}-${edgeRaw.target}`;
            const caseCount = edgeRaw.cases ? edgeRaw.cases.length : 0;
            const label = `${caseCount} case${caseCount === 1 ? "" : "s"}`;
            const titleLines = [
              `<strong>Person:</strong> ${edgeRaw.person}`,
              `<strong>Location:</strong> ${edgeRaw.location}`,
              `<strong>Cases:</strong> ${edgeRaw.cases ? edgeRaw.cases.join(", ") : "N/A"}`,
            ];
            graphEdgeMap.set(edgeId, { ...edgeRaw, id: edgeId });
            return {
              id: edgeId,
              from: edgeRaw.source,
              to: edgeRaw.target,
              width: Math.max(1, edgeRaw.weight || caseCount || 1),
              color: { color: "#94a3b8" },
              arrows: "",
              label,
              title: titleLines.join("<br/>"),
            };
          })
        );

        const networkOptions = {
          layout: {
            improvedLayout: true,
            randomSeed: 42,
          },
          nodes: {
            shape: "dot",
            font: { color: "#0f172a", face: "Arial" },
            scaling: { min: 10, max: 40 },
          },
          edges: {
            font: { color: "#f8fafc", size: 10, align: "horizontal" },
            selectionWidth: 2,
            hoverWidth: 0,
            smooth: {
              enabled: true,
              type: "dynamic",
            },
          },
          interaction: {
            hover: true,
            tooltipDelay: 120,
            zoomView: true,
            dragView: true,
          },
          physics: {
            solver: "forceAtlas2Based",
            stabilization: {
              enabled: true,
              iterations: 800,
              fit: true,
            },
            forceAtlas2Based: {
              gravitationalConstant: -35,
              centralGravity: 0.01,
              springConstant: 0.1,
              damping: 0.4,
              avoidOverlap: 0.6,
            },
            minVelocity: 0.75,
          },
        };

        caseNetwork = new vis.Network(
          container,
          { nodes, edges },
          networkOptions
        );

        caseNetwork.once("stabilizationIterationsDone", () => {
          caseNetwork.setOptions({ physics: { enabled: false } });
        });

        caseNetwork.on("click", (params) => {
          if (params.nodes && params.nodes.length > 0) {
            const node = graphNodeMap.get(params.nodes[0]);
            if (node) {
              showNodeDetails(node);
            }
            return;
          }
          if (params.edges && params.edges.length > 0) {
            const edge = graphEdgeMap.get(params.edges[0]);
            if (edge) {
              showEdgeDetails(edge);
            }
          }
        });
      }

      function showNodeDetails(node) {
        const entityType = node.type === "person" ? "PERSON" : "LOCATION";
        const lines = [
          `=== ${entityType} NODE ===`,
          `Value: ${node.label}`,
          `Linked cases (${node.cases ? node.cases.length : 0}):`,
        ];
        if (node.cases && node.cases.length) {
          node.cases.forEach((id, idx) => {
            lines.push(`  ${idx + 1}. ${id}`);
          });
        } else {
          lines.push("  (No cases recorded for this entity)");
        }
        lines.push(
          "\nCopy a case ID above and use the 'Load Case by ID' section to open its full report."
        );
        document.getElementById("report-output").value = lines.join("\n");
      }

      function showEdgeDetails(edge) {
        const lines = [
          "=== PERSON ‚Üî LOCATION LINK ===",
          `Person: ${edge.person}`,
          `Location: ${edge.location}`,
          `Shared cases (${edge.cases ? edge.cases.length : 0}):`,
        ];
        if (edge.case_details && edge.case_details.length) {
          edge.case_details.forEach((detail) => {
            const summary = (detail.summary || "").replace(/\s+/g, " ").trim();
            lines.push(`  - ${detail.case_id}${summary ? `: ${summary}` : ""}`);
          });
        } else if (edge.cases && edge.cases.length) {
          edge.cases.forEach((caseId) => lines.push(`  - ${caseId}`));
        } else {
          lines.push("  (No case summaries available)");
        }
        lines.push(
          "\nTip: copy one of the case IDs above and load it with the 'Load Case by ID' form."
        );
        document.getElementById("report-output").value = lines.join("\n");
      }

      async function fetchReportById(caseId) {
        if (!caseId) return;
        try {
          showStatus(`Loading case ${caseId}...`, true);
          const res = await fetch(`${API}/reports/${caseId}`);
          if (!res.ok) {
            const msg = await res.text();
            throw new Error(msg || `Unable to load case ${caseId}`);
          }
          const data = await res.json();
          document.getElementById("report-output").value = formatReport(data);
          showStatus(`üìÅ Viewing report for ${caseId}`, false);
        } catch (error) {
          console.error("Fetch report error:", error);
          showStatus(`Failed to load case ${caseId}: ${error.message}`, false);
        }
      }

      document.getElementById("manual-case-button").addEventListener("click", () => {
        const input = document.getElementById("manual-case-id");
        const caseId = input.value.trim();
        if (!caseId) {
          alert("Please enter a case ID.");
          return;
        }
        fetchReportById(caseId);
      });

      document.getElementById("manual-case-id").addEventListener("keypress", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          document.getElementById("manual-case-button").click();
        }
      });

      document.getElementById("upload-form").addEventListener("submit", async (e) => {
        e.preventDefault();
        const fileInput = document.getElementById("file-input");
        if (!fileInput.files.length) {
          alert("Please select a file first");
          return;
        }

        const file = fileInput.files[0];
        let caseId = null;
        let artifactPath = null;
        showStatus("Uploading file...", true);
        updateProgress(10);

        try {
          // Step 1: Upload file(s) or zip archive
          const formData = new FormData();
          // Multiple files -> upload folder endpoint
          if (fileInput.files.length > 1 || file.name.toLowerCase().endsWith('.zip')) {
            for (let i = 0; i < fileInput.files.length; i++) {
              formData.append('files', fileInput.files[i]);
            }
            showStatus('Uploading files...', true);
            updateProgress(20);
            const uploadRes = await fetch(`${API}/evidence/upload_folder`, {
              method: 'POST',
              body: formData,
            });
            if (!uploadRes.ok) {
              throw new Error(`Upload failed: ${uploadRes.statusText}`);
            }
            const uploadData = await uploadRes.json();
            caseId = uploadData.case_id;
            // Trigger case-level processing
            showStatus('Files uploaded. Processing with AI...', true);
            updateProgress(40);
            const processRes = await fetch(`${API}/evidence/process_case`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ case_id: caseId })
            });
            if (!processRes.ok) {
              throw new Error(`Processing failed: ${processRes.statusText}`);
            }
          } else {
            // Single file flow uses existing upload endpoint
            formData.append('file', file);
            showStatus('Uploading file...', true);
            updateProgress(20);
            const uploadRes = await fetch(`${API}/evidence/upload`, {
              method: 'POST',
              body: formData
            });
            if (!uploadRes.ok) {
              throw new Error(`Upload failed: ${uploadRes.statusText}`);
            }
            const uploadData = await uploadRes.json();
            caseId = uploadData.case_id;
            artifactPath = uploadData.stored_path;

            showStatus('File uploaded. Processing with AI...', true);
            updateProgress(40);
            // Step 2: Process evidence (automatic)
            const processRes = await fetch(`${API}/evidence/process`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ case_id: caseId, artifact_path: artifactPath })
            });
            if (!processRes.ok) {
              throw new Error(`Processing failed: ${processRes.statusText}`);
            }
          }

          // Upload success validated above in branch-specific checks

          // upload/process handled above, now poll for reports

          showStatus("AI processing in progress... This may take 2-5 minutes on first run (downloading models)...", true);
          updateProgress(60);

          // Step 3: Wait for processing to complete (now synchronous, but we still poll for report)
          // Poll for report (check every 2 seconds, max 6 minutes for first-time model downloads)
          let attempts = 0;
          const maxAttempts = 180; // 180 attempts * 2 seconds = 6 minutes
          let reportData = null;

          while (attempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 2000)); // Check every 2 seconds
            attempts++;
            const elapsedSeconds = attempts * 2;
            const progressPercent = Math.min(60 + (attempts * 0.2), 98); // Progress from 60% to 98%
            updateProgress(progressPercent);

            try {
              const reportRes = await fetch(`${API}/reports/${caseId}`);
              if (reportRes.ok) {
                const jsonData = await reportRes.json();
                // Debug: log the response
                console.log("Report API response:", jsonData);
                // Validate that we got valid data
                if (jsonData && (jsonData.case_id || jsonData.caseId)) {
                  // Handle both snake_case and camelCase
                  reportData = jsonData;
                  // Normalize case_id if needed
                  if (!reportData.case_id && reportData.caseId) {
                    reportData.case_id = reportData.caseId;
                  }
                  break;
                } else {
                  console.warn("Report data incomplete, waiting...", jsonData);
                  // If we got a response but it's incomplete, log it for debugging
                  if (jsonData) {
                    console.warn("Received data keys:", Object.keys(jsonData));
                  }
                }
              } else if (reportRes.status === 202) {
                // 202 Accepted = processing in progress, continue polling
                // Don't log this as an error, it's expected
              } else if (reportRes.status === 404) {
                // 404 = not started yet, continue polling
                // Don't log this as an error, it's expected
              } else {
                // Other error status - try to get error message
                const errorText = await reportRes.text();
                console.warn(`Report check returned status ${reportRes.status}:`, errorText);
              }
            } catch (err) {
              // Network error, continue polling
              // Don't log this as an error during polling
              console.warn("Network error during polling (expected):", err.message);
            }

            // Show elapsed time with helpful message
            const minutes = Math.floor(elapsedSeconds / 60);
            const seconds = elapsedSeconds % 60;
            let statusMsg = "";
            if (elapsedSeconds < 30) {
              statusMsg = `Processing started... (${elapsedSeconds}s)`;
            } else if (elapsedSeconds < 120) {
              statusMsg = `Processing... Models may be downloading (${minutes}m ${seconds}s)`;
            } else {
              statusMsg = `Still processing... First-time model download can take 3-5 minutes (${minutes}m ${seconds}s)`;
            }
            showStatus(statusMsg, true);
          }

          if (!reportData) {
            throw new Error("Report generation timed out after 6 minutes. The BERT model (440MB) may still be downloading. Please wait a bit longer and try refreshing, or check server logs.");
          }

          // Validate report data before formatting
          if (!reportData.case_id) {
            console.error("Invalid report data received:", reportData);
            throw new Error("Received invalid report data from server. Please check server logs.");
          }

          showStatus("Processing complete! Generating report...", true);
          updateProgress(100);

          // Step 4: Display formatted report
          console.log("Formatting report with data:", reportData);
          const formattedReport = formatReport(reportData);
          document.getElementById("report-output").value = formattedReport;
          loadCaseGraph(reportData.case_id);

          showStatus("‚úÖ Analysis complete! Report generated below.", false);
          
          // Hide progress after 3 seconds
          setTimeout(() => {
            document.getElementById("status-message").style.display = "none";
          }, 3000);

        } catch (error) {
          console.error("Full error:", error);
          showStatus(`‚ùå Error: ${error.message}`, false);
          const errorDetails = `Error: ${error.message}\n\nPlease try again or check:\n1. Server is running\n2. File format is supported (.pdf, .txt, .jpg, .png)\n3. File is not corrupted\n4. Check browser console (F12) for more details`;
          document.getElementById("report-output").value = errorDetails;
        }
      });

      // Initial graph render on page load
      loadCaseGraph();
    </script>
  </body>
</html>

